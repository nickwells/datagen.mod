package datagen

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

// NegativeFormat encodes how negative values should be expressed.
//
// NegFmtMinus means that a negative value should be shown with a leading
// minus sign.
//
// NegFmtAccounts means that a negative value should be indicated by being
// shown in brackets.
type NegativeFormat int

const (
	NegFmtMinus NegativeFormat = iota
	NegFmtAccounts
)

// NumFmt records details of how to format a number. These include the
// decimal place character (or radix point), the digit group separator and
// how many digits are in the groups of digits.
type NumFmt struct {
	prefix string
	suffix string

	useZeroVal bool
	zeroVal    string

	decimalSep string

	digitGrpSep string
	sepCount    []int

	negFmt NegativeFormat
}

// NumFmtOptFunc is the type of a parameter to the NewNumFmt function. It is
// used to supply optional parameters.
type NumFmtOptFunc func(nf *NumFmt) error

// NumFmtSetPrefix sets the prefix on a NumFmt. This is what appears before
// any of the number has been generated.
func NumFmtSetPrefix(s string) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.prefix = s
		return nil
	}
}

// NumFmtSetSuffix sets the suffix on a NumFmt. This is what appears after
// the rest of the number has been generated.
func NumFmtSetSuffix(s string) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.suffix = s
		return nil
	}
}

// NumFmtSetZeroVal sets the zeroVal on a NumFmt. This is the value to be
// returned when the value is zero. If it has not been set then the zero
// value as generated by the rest of the number format values will be
// generated.
func NumFmtSetZeroVal(s string) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.zeroVal = s
		nf.useZeroVal = true

		return nil
	}
}

// NumFmtSetDecimalSep sets the decimalSep on a NumFmt. This is the value
// (typically a single character) to appear between the whole number and
// fractional parts of the value.
func NumFmtSetDecimalSep(s string) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.decimalSep = s
		return nil
	}
}

// NumFmtSetDigitGrpSep sets the digitGrpSep on a NumFmt. This is the value
// (typically a single character) to appear between the groups of digits as
// specified by the sepCount values.
func NumFmtSetDigitGrpSep(s string) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.digitGrpSep = s
		return nil
	}
}

// NumFmtSetSepCount sets the sepCount on a NumFmt. This is the number of
// digits in the groups of digits separated by the digitGrpSep. Multiple
// values can be given and the first will be used as the number of digits in
// the first group, the second value used for the second group and so on. The
// last value given is used repeatedly thereafter.
func NumFmtSetSepCount(sc ...int) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.sepCount = sc
		return nil
	}
}

// NumFmtSetNegFmt sets the format of negative values on a NumFmt. The
// default format places a minus sign at the front of the value, after any
// prefix.
func NumFmtSetNegFmt(negFmt NegativeFormat) NumFmtOptFunc {
	return func(nf *NumFmt) error {
		nf.negFmt = negFmt
		return nil
	}
}

// NewNumFmt generates and returns a new NumFmt. The default value returned
// will generate a value with a decimal separator of "," and groups of three
// digits before the decimal separated by commas.
func NewNumFmt(opts ...NumFmtOptFunc) *NumFmt {
	nf := &NumFmt{
		decimalSep:  ".",
		digitGrpSep: ",",
		sepCount:    []int{3},
	}

	for _, o := range opts {
		if err := o(nf); err != nil {
			panic(err)
		}
	}

	return nf
}

// makeFactor returns 10^v (if v > 0, 1 otherwise)
func makeFactor[T constraints.Float | constraints.Integer](v int) T {
	var f T = 1
	for ; v > 0; v-- {
		f *= 10
	}

	return f
}

// SepFactors returns a slice containing the appropriate factor for each
// sepCount.
func SepFactors[T constraints.Float | constraints.Integer](sc []int) []T {
	factors := make([]T, len(sc))
	for i, d := range sc {
		factors[i] = makeFactor[T](d)
	}

	return factors
}

// UnsignedMkStrFunc returns a string-maker function which can be use to
// format an unsigned integer value according to the NumFmt.
func UnsignedMkStrFunc[T constraints.Unsigned](nf NumFmt) func(T) string {
	factors := SepFactors[T](nf.sepCount)

	return func(v T) string {
		if v == 0 && nf.useZeroVal {
			return nf.zeroVal
		}

		s := nf.prefix

		var parts []string

		if len(nf.sepCount) == 0 {
			parts = append(parts, fmt.Sprintf("%d", v))
		} else {
			i := 0
			for v > 0 {
				vNew, vRem := v/factors[i], v%factors[i]
				if vNew == 0 {
					parts = append(parts, fmt.Sprintf("%d", vRem))
				} else {
					parts = append(parts,
						fmt.Sprintf(
							"%s%0*d", nf.digitGrpSep, nf.sepCount[i], vRem))
				}

				v = vNew

				if i < len(factors)-1 {
					i++
				}
			}

			if len(parts) == 0 {
				parts = append(parts, "0")
			}
		}

		for i := len(parts) - 1; i >= 0; i-- {
			s += parts[i]
		}

		s += nf.suffix

		return s
	}
}

// SignedMkStrFunc returns a string-maker function which can be use to format
// a signed integer value according to the NumFmt.
func SignedMkStrFunc[T constraints.Signed](nf NumFmt) func(T) string {
	innerNF := nf
	innerNF.prefix = ""
	innerNF.suffix = ""
	innerNF.useZeroVal = false
	uFunc := UnsignedMkStrFunc[uint64](innerNF)

	return func(v T) string {
		if v == 0 && nf.useZeroVal {
			return nf.zeroVal
		}

		isNegative := v < 0
		if isNegative {
			v *= -1
		}

		s := nf.prefix

		if isNegative && nf.negFmt == NegFmtMinus {
			s += "-"
		}

		s += uFunc(uint64(v))

		s += nf.suffix

		if isNegative && nf.negFmt == NegFmtAccounts {
			return "(" + s + ")"
		}

		return s
	}
}
